---
phase: 04-mcp-server
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - mcp_server.py
  - app.py
autonomous: true

must_haves:
  truths:
    - "analyze_video tool accepts video URL or ID as parameter"
    - "analyze_video tool extracts video ID from full YouTube URLs automatically"
    - "analyze_video tool returns transcript, metadata, statistics, and comments in one call"
    - "analyze_video tool uses ThreadPoolExecutor for parallel data fetching"
    - "analyze_video tool handles partial success gracefully (returns available data with errors)"
    - "analyze_video tool returns quota_cost=4 (transcript=0, metadata=1, stats=1, comments=1)"
    - "Tool is registered with MCP and discoverable via /mcp/tools/list"
  artifacts:
    - path: "mcp_server.py"
      provides: "analyze_video MCP tool"
      exports: ["analyze_video"]
      min_lines: 100
    - path: "app.py"
      provides: "get_comments_for_video helper function for MCP tool"
      exports: ["get_comments_for_video"]
      min_lines: 30
  key_links:
    - from: "mcp_server.py analyze_video tool"
      to: "app.py get_unified_video_data"
      via: "import and function call"
      pattern: "from app import get_unified_video_data|get_video_comments"
    - from: "analyze_video tool"
      to: "ThreadPoolExecutor"
      via: "get_unified_video_data function call"
      pattern: "get_unified_video_data\\(.*\\)"
    - from: "analyze_video tool"
      to: "video ID extraction"
      via: "regex or URL parsing"
      pattern: "re\\.\\w+.*video|extract.*video.*id"
---

<objective>
Implement analyze_video MCP tool that fetches complete YouTube video data (transcript, metadata, statistics, comments) in parallel.

Purpose: Provide AI agents with a single tool to retrieve all YouTube video data, enabling comprehensive video analysis workflows.
Output: Working analyze_video MCP tool that returns unified video data bundle with graceful degradation for partial failures.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-mcp-server/04-CONTEXT.md
@app.py
@.planning/phases/04-mcp-server/04-01-SUMMARY.md
@.planning/phases/01-core-metadata/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add get_comments_for_video helper to app.py</name>
  <files>app.py</files>
  <action>
    Add a new function `get_comments_for_video(video_id)` to app.py after the get_unified_video_data() function.

    The function should:
    1. Use @lru_cache(maxsize=100) decorator for caching
    2. Call get_video_comments(video_id, max_results=100)
    3. Return the comments list directly (no wrapper dict needed)
    4. Have same error handling as existing endpoints (catches HttpError for disabled comments)

    This function provides a simple interface for the MCP tool to fetch comments without dealing with Flask request/response structures.

    Place the function definition after line 234 (after get_unified_video_data function ends).
  </action>
  <verify>grep -q "def get_comments_for_video" app.py</verify>
  <done>app.py has get_comments_for_video() function that returns comments list for a video_id</done>
</task>

<task type="auto">
  <name>Implement analyze_video MCP tool in mcp_server.py</name>
  <files>mcp_server.py</files>
  <action>
    Replace the placeholder analyze_video_placeholder function with a full implementation:

    1. Import required functions from app.py: get_unified_video_data, get_video_comments, get_comments_for_video, is_valid_video_id
    2. Import re for regex-based video ID extraction
    3. Create a helper function extract_video_id(video_url_or_id) that:
       - Checks if input matches 11-char video ID pattern (use existing is_valid_video_id)
       - If not, extracts video ID from YouTube URLs using regex pattern: r'(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})'
       - Returns extracted video ID or raises ValueError with clear message
    4. Implement @mcp.tool decorated analyze_video(video_url_or_id: str) -> dict function:
       - Extract video ID using helper function
       - Call get_unified_video_data(video_id) to get transcript, metadata, statistics
       - Fetch comments separately using get_comments_for_video(video_id) in try/except
       - Build result dict with all 4 data types, success flag, partial_success flag, quota_cost=4, errors array
       - Handle transcript failures gracefully (add to errors, set partial_success=True)
       - Handle comment failures (add to errors, set partial_success=True, don't fail entire request)
       - Return structured JSON with all data

    Tool metadata:
       - Add description: "Fetch complete YouTube video data including transcript, metadata, statistics, and comments. Accepts video URL or ID. Returns full data bundle with graceful degradation if some data is unavailable."
       - Add parameter schema: video_url_or_id (string, required) - "YouTube video URL or 11-character video ID"
  </action>
  <verify>grep -q "def analyze_video" mcp_server.py && grep -q "extract_video_id" mcp_server.py</verify>
  <done>mcp_server.py has analyze_video tool that extracts video ID, fetches all 4 data types, handles partial success, and returns structured JSON</done>
</task>

<task type="auto">
  <name>Test analyze_video tool with MCP inspector</name>
  <files>None (testing)</files>
  <action>
    Test the analyze_video tool using the MCP protocol:

    1. Start MCP server: `python mcp_server.py`
    2. In another terminal, use curl to test MCP tool listing:
       `curl http://localhost:8000/mcp/tools/list`
    3. Verify analyze_video appears in tool list
    4. Test tool with valid video ID using MCP protocol call
    5. Verify response includes all 4 data types (transcript, metadata, statistics, comments)
    6. Verify quota_cost=4 is present
    7. Test with invalid video ID to verify error handling

    This confirms the tool is properly registered with MCP and returns correct data structure.

    Note: Skip this task if MCP inspector is not available - manual verification during execution is acceptable.
  </action>
  <verify>python -c "from mcp_server import mcp; print('analyze_video' in [t.name for t in mcp._tools.values()])"</verify>
  <done>analyze_video tool is registered with FastMCP and callable via MCP protocol</done>
</task>

</tasks>

<verification>
After completion, verify:
1. `python -c "from mcp_server import analyze_video, extract_video_id; print('Functions imported successfully')"` - no import errors
2. Video ID extraction works: `python -c "from mcp_server import extract_video_id; print(extract_video_id('https://www.youtube.com/watch?v=dQw4w9WgXcQ'))"` returns 'dQw4w9WgXcQ'
3. Server starts successfully: `python mcp_server.py`
4. Tool is discoverable: Check MCP tools list includes analyze_video with description
5. Test with real video ID: Call analyze_video('dQw4w9WgXcQ') and verify response has all 4 data types
6. Test partial success: Use video with disabled comments, verify errors array includes comment error, other data present
7. Quota cost is set to 4 in response
</verification>

<success_criteria>
1. extract_video_id() function extracts video IDs from full URLs and validates bare IDs
2. analyze_video tool is registered with FastMCP and appears in tools list
3. analyze_video tool returns all 4 data types (transcript, metadata, statistics, comments)
4. Parallel fetching is used (via get_unified_video_data which uses ThreadPoolExecutor)
5. Partial success is handled gracefully (errors array, partial_success flag)
6. quota_cost=4 is included in response
7. Tool has clear description and parameter schema for LLM consumption
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-server/04-02-SUMMARY.md` with:
- Tool implementation details (video ID extraction regex, data fetching logic)
- Test results with actual video IDs
- Performance characteristics (parallel fetching reduces latency)
- Error handling behavior (partial success examples)
- Deviations from plan if any
</output>
