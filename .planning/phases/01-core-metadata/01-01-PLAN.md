---
phase: 01-core-metadata
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - app.py
autonomous: true

must_haves:
  truths:
    - "User can fetch video metadata via GET /api/metadata/<video_id>"
    - "Response includes title, description, tags, category_id, thumbnails, channel_title, published_at"
    - "Response includes quota_cost field set to 1"
    - "Invalid video IDs return 400 with 'Invalid video ID format' error"
    - "Non-existent videos return 404 with 'Video not found' error"
    - "Metadata responses are cached using LRU cache (maxsize 100)"
    - "Endpoint is rate-limited to 10 requests per minute per IP"
  artifacts:
    - path: "requirements.txt"
      contains: "isodate"
    - path: "app.py"
      provides: "Video metadata fetching via YouTube Data API v3"
      exports: ["get_video_metadata", "/api/metadata/<video_id>"]
      min_lines: 50
  key_links:
    - from: "app.py"
      to: "youtube.videos().list"
      via: "google-api-python-client"
      pattern: "youtube\\.videos\\(\\)\\.list\\(.*part='snippet'"
    - from: "/api/metadata/<video_id>"
      to: "get_video_metadata()"
      via: "function call"
      pattern: "get_video_metadata\\(video_id\\)"
---

<objective>
Implement video metadata endpoint that returns YouTube video metadata (title, description, tags, category, thumbnails, channel info, publish date) via `/api/metadata/<video_id>`.

Purpose: Enable API consumers to retrieve essential video metadata for content analysis, search indexing, and display purposes.
Output: Working `/api/metadata/<video_id>` endpoint with LRU caching, rate limiting, and graceful error handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-metadata/01-CONTEXT.md
@.planning/phases/01-core-metadata/01-RESEARCH.md
@app.py
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Add isodate dependency</name>
  <files>requirements.txt</files>
  <action>
    Add `isodate>=0.6.1` to requirements.txt. This library is needed for parsing ISO 8601 duration strings in the statistics endpoint (Plan 02), but we install it now since both plans run in parallel.

    Add the line:
    isodate>=0.6.1
  </action>
  <verify>grep -q "isodate" requirements.txt</verify>
  <done>requirements.txt contains isodate>=0.6.1 dependency</done>
</task>

<task type="auto">
  <name>Implement get_video_metadata function</name>
  <files>app.py</files>
  <action>
    Add the `get_video_metadata()` function to app.py after the existing `get_video_comments()` function:

    1. Use @lru_cache(maxsize=100) decorator for caching
    2. Call youtube.videos().list() with part='snippet' and id=video_id
    3. Check if response['items'] is empty - raise Exception("Video not found") if so
    4. Extract snippet data: title, description, tags, categoryId, thumbnails, channelTitle, publishedAt
    5. Return flat dictionary with keys: title, description, tags (default [] if missing), category_id, thumbnails (full dict from API), channel_title, published_at
    6. Handle HttpError from google.auth.exceptions: except HttpError as e, then check e.resp.status == 403 or e.resp.status == 404 and raise Exception with user-friendly message

    Use the existing error handling pattern from get_video_comments() as reference.
  </action>
  <verify>grep -q "def get_video_metadata" app.py</verify>
  <done>get_video_metadata() function exists, uses YouTube API with part='snippet', returns flat dict with all metadata fields</done>
</task>

<task type="auto">
  <name>Implement /api/metadata/<video_id> endpoint</name>
  <files>app.py</files>
  <action>
    Add the `/api/metadata/<video_id>` route after the existing `/api/comments/<video_id>` route:

    1. Use @app.route('/api/metadata/<video_id>', methods=['GET'])
    2. Apply @limiter.limit("10 per minute") decorator
    3. Validate video_id using is_valid_video_id() - return 400 with {'error': 'Invalid video ID format'} if invalid
    4. Call get_video_metadata(video_id) and store result
    5. Return jsonify with: success=True, video_id, quota_cost=1, metadata=<result>
    6. Wrap in try/except handling:
       - "Video not found" -> return 404 with {'error': 'Video not found'}
       - "Access forbidden" -> return 403 with {'error': 'Access forbidden', 'details': 'Quota may be exceeded or video is private'}
       - Other errors -> return 500 with {'error': 'An unexpected error occurred', 'details': <error_message>}

    Follow the exact response pattern from existing transcript/comments endpoints for consistency.
  </action>
  <verify>grep -q "'/api/metadata/<video_id>'" app.py</verify>
  <done>/api/metadata/<video_id> endpoint exists, validates video ID, returns metadata with quota_cost=1, handles all error cases</done>
</task>

</tasks>

<verification>
After completion, verify:
1. `python -c "import app; print('Import successful')"` - no syntax errors
2. Server starts with `python main.py` - no import/dependency errors
3. Manual test: `curl http://localhost:5000/api/metadata/dQw4w9WgXcQ` returns valid JSON with metadata fields
4. Invalid video ID test: `curl http://localhost:5000/api/metadata/invalid` returns 400
</verification>

<success_criteria>
1. GET /api/metadata/<valid_video_id> returns 200 with success=True, video_id, quota_cost=1, and metadata object
2. Metadata object contains: title, description, tags, category_id, thumbnails, channel_title, published_at
3. Invalid video ID format returns 400 error
4. Non-existent video returns 404 error
5. Subsequent requests for same video_id return cached response (verify via timing/response consistency)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-metadata/01-01-SUMMARY.md` with:
- What was implemented (metadata endpoint, function, route)
- Any deviations from plan
- Key decisions made (field names, error handling approach)
- Test results from verification
</output>
